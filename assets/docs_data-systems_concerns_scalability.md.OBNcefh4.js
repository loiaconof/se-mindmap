import{_ as a,a as t,o as s,ah as r}from"./chunks/framework.Ddlh_Zg3.js";const m=JSON.parse('{"title":"Scalability","description":"","frontmatter":{},"headers":[],"relativePath":"docs/data-systems/concerns/scalability.md","filePath":"docs/data-systems/concerns/scalability.md"}'),i={name:"docs/data-systems/concerns/scalability.md"};function o(n,e,l,c,h,d){return s(),t("div",null,e[0]||(e[0]=[r('<h1 id="scalability" tabindex="-1">Scalability <a class="header-anchor" href="#scalability" aria-label="Permalink to “Scalability”">​</a></h1><p><strong>Scalability</strong> is the term used to describe a system&#39;s ability to cope with increased load.</p><p>Even if a system is working reliably today, that doesn&#39;t mean it will necessarily work reliably in the future, perhaps it will process much larger volumes of data than it did before.</p><h2 id="describing-load" tabindex="-1">Describing Load <a class="header-anchor" href="#describing-load" aria-label="Permalink to “Describing Load”">​</a></h2><p>Load can be described with a few numbers which are called <strong>load parameters</strong>. The choice of parameters depends on the architecture of your system, they may be:</p><ul><li>request per second to a web server</li><li>ratio of reads to writes in a database</li><li>number of simultaneously active users in a chat room</li></ul><p><a href="https://medium.com/@gitaeklee/system-design-fan-out-with-twitter-d071a6799893" target="_blank" rel="noreferrer">Twitter Fan-Out example</a></p><h2 id="describing-performance" tabindex="-1">Describing Performance <a class="header-anchor" href="#describing-performance" aria-label="Permalink to “Describing Performance”">​</a></h2><p>Once describe the load on the system you can investigate on what happens when the load increases. You can look it in two ways:</p><ul><li>how is the system is affected increasing a load parameter keeping the system resources unchanged?</li><li>how much do you need to increase the resources if you want to keep the performance unchanged increasing a load parameter?</li></ul><p>The first step is to focus on a performance metric—usually time (e.g., how many records can be processed per second). In systems that handle a variety of operations, this metric can vary widely. For that reason, it’s important to think of performance not as a single value, but as a <strong>distribution</strong> of values you can measure.</p><p>Most operations are reasonably fast, but there are occasional outliers that take much longer. Perhaps the slow operations are intrinsically more expensive or maybe the loss of a network packet and TCP retrasmission.</p><p>To capture and analyze these variations, use <strong>percentiles</strong>.</p><h2 id="approaches-for-coping-with-load" tabindex="-1">Approaches for Coping with Load <a class="header-anchor" href="#approaches-for-coping-with-load" aria-label="Permalink to “Approaches for Coping with Load”">​</a></h2><p>There are two main approces:</p><ul><li><strong>Scaling up</strong> - vertical scaling</li><li><strong>Scaling out</strong> - horizontal scaling</li></ul><p>While data systems are stateful, the common choice is to scale up to keep the database on a single node. As the tools of abstractions for distributed systems get better, this common wisdom may change.</p>',17)]))}const u=a(i,[["render",o]]);export{m as __pageData,u as default};
