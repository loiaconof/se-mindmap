import{_ as t,c as r,o as a,af as i}from"./chunks/framework.D3_6tgji.js";const p=JSON.parse('{"title":"Kubernetes","description":"","frontmatter":{},"headers":[],"relativePath":"docs/devops/kubernetes/index.md","filePath":"docs/devops/kubernetes/index.md"}'),n={name:"docs/devops/kubernetes/index.md"};function o(s,e,l,c,d,h){return a(),r("div",null,e[0]||(e[0]=[i('<h1 id="kubernetes" tabindex="-1">Kubernetes <a class="header-anchor" href="#kubernetes" aria-label="Permalink to “Kubernetes”">​</a></h1><p>Kubernetes aims to orchestrate its containers transparently.</p><p>Kubernetes is a distributed system, so the different components are &quot;scattered&quot; on different servers or machines within one or more networks.</p><h2 id="core-concepts" tabindex="-1">Core concepts <a class="header-anchor" href="#core-concepts" aria-label="Permalink to “Core concepts”">​</a></h2><ul><li><strong>Cluster</strong>: <ul><li>the set of virtual machines or physical servers within one or more networks</li></ul></li></ul><h2 id="cluster" tabindex="-1">Cluster <a class="header-anchor" href="#cluster" aria-label="Permalink to “Cluster”">​</a></h2><p>The cluster is the set of nodes (virtual machines or physical servers within one or more networks) within the Kubernetes domain.</p><p>There are two different types of nodes:</p><ul><li><strong>Control Plane</strong>: <ul><li>it is responsible for orchestrating the containers and keeping them in the desired state in the cluster</li></ul></li><li><strong>Worker</strong><ul><li>it is considered an application node</li></ul></li></ul><h2 id="control-plane" tabindex="-1">Control Plane <a class="header-anchor" href="#control-plane" aria-label="Permalink to “Control Plane”">​</a></h2><p>The components running on these nodes work together to accept requests, route them, authenticate clients, configure cluster-wide networking, and manage system scaling.</p><h3 id="etcd" tabindex="-1">Etcd <a class="header-anchor" href="#etcd" aria-label="Permalink to “Etcd”">​</a></h3><ul><li>configuration persistence using a lightweight key-value database <ul><li>stores information inside the <code>/registry</code> folder</li></ul></li><li>align nodes when a configuration changes or a node is added</li><li>helps maintain the cluster state by electing leaders using the Raft consensus algorithm <ul><li>maintains high availability even if one or more nodes fail</li></ul></li></ul><h3 id="api-server" tabindex="-1">API Server <a class="header-anchor" href="#api-server" aria-label="Permalink to “API Server”">​</a></h3><ul><li>exposes APIs to communicate with kubernetes</li><li>use of TLS protocol to handle authentication</li><li>communication protocol <ul><li>default <code>REST HTTP</code></li><li>some components like <code>scheduler</code> and <code>controller</code> communicate with the <code>API Server</code> via gRPC</li></ul></li></ul><h3 id="kube-scheduler" tabindex="-1">Kube Scheduler <a class="header-anchor" href="#kube-scheduler" aria-label="Permalink to “Kube Scheduler”">​</a></h3>',16)]))}const m=t(n,[["render",o]]);export{p as __pageData,m as default};
